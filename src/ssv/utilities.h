// Miscellaneous utility routines.

#ifndef UTILITIES_H
#define UTILITIES_H

#include <sys/types.h>

#include <glib.h>

///////////////////////////////////////////////////////////////////////////////
//
// Error Handling with GError
//
// For error reporting via GError, we have our own error domain.  All
// errors generated by functions in the header generate an error in
// this domain.  Any functions declared in this header that want to
// use GError to report errors should have appropriate error codes to
// the MyGUtilitiesError enumeration.
//
///////////////////////////////////////////////////////////////////////////////

GQuark
my_g_utilities_error_quark (void);

#define MY_G_UTILITIES_ERROR g_shell_error_quark ()

typedef enum
{
  // File and directory validation failures.
  MY_G_UTILITIES_ERROR_G_STAT_FAILED,
  MY_G_UTILITIES_ERROR_NOT_A_DIRECTORY,
  MY_G_UTILITIES_ERROR_NOT_A_REGULAR_FILE,
  MY_G_UTILITIES_ERROR_ACCESS_DENIED,
  MY_G_UTILITIES_ERROR_READ_ACCESS_DENIED
} MyGUtilitiesError;

GQuark g_shell_error_quark (void);

///////////////////////////////////////////////////////////////////////////////

// Return the file size of file associated with fd (as obtained using
// fstat) in bytes.
off_t
file_size (int fd);

// Get a process-unique serial number.  The first call of this
// function within a process returns 0, and each subsequent call
// retrieves the next number.
unsigned int
get_next_serial_number (void);

// Ensure that the last character of string is a '/' by adding a slash
// if one isn't already there.  For convenience, return string.
GString *
ensure_slash_terminated (GString *string);

// Return a new GString instance consisting of string with all
// characters for which isspace() is true replaced with underscores.
GString *
spaces_to_underscores (GString *string);

// Make a new string containing a unique path name to a file in
// directory by combining together directory, a '/' character if
// directory doesn't end in one, prefix, hostname, process id, and an
// additional process-unique serial number, and appending them to
// directory.  The unique serial number is retrieved in a thread-safe
// fashion.
GString *
make_unique_tmp_file_name (const char *directory, const char *prefix);

// Create a new GString and printf some stuff into it.
GString *
my_g_string_new_printf (const char *format, ...)
// The GNU C compiler can give us some special help if compiling with
// -Wformat or a warning option that implies it.
#ifdef __GNUC__
  // Function attribute format says function is variadices a la printf,
  // with argument 1 its format spec and argument 2 its first optional
  // argument corresponding to the spec.es
  __attribute__ ((format (printf, 1, 2)))
#endif 
; /* <-- Semicolon for prototype.  */

// Free a GString instance, and its actual character data as well.
void
my_g_string_free (GString *instance);

// Return true iff key exists in hash_table (useful to avoid having to
// use the cumbersome g_hash_table_lookup_extended when dealing with
// tables which may contain NULL values (or integers which might be 0
// stored as pointers).
gboolean
my_g_hash_table_entry_exists (GHashTable *hash_table, gconstpointer key);

// Return a new GPtrArray containing all the keys of hash_table.
GPtrArray *
my_g_hash_table_keys (GHashTable *hash_table);

// Return a new GPtrArray containing all the pointers stored in hash_table.
GPtrArray *
my_g_hash_table_values (GHashTable *hash_table);

// Fill in keys and values arguments with new GPtrArray instances
// containing the keys and values of hash_table, in corresponding
// order.
void
my_g_hash_table_keys_and_values (GHashTable *hash_table, GPtrArray **keys,
				 GPtrArray **values);

// Add all the entries in other to self (without changing other).
void
my_g_ptr_array_add_entries (GPtrArray *self, GPtrArray *other);

// Return a new GPtrArray containing all the pointers in a, followed
// by all the pointers in b.
GPtrArray *
my_g_ptr_array_sum (GPtrArray *a, GPtrArray *b);

// Compare a with b, treating both as (unordered) multisets by
// comparing elements using comparator cmp.
gboolean
my_g_ptr_array_equals_as_multiset (GPtrArray *a, GPtrArray *b, GEqualFunc cmp);

typedef void (*FreeFunc)(gpointer element);

// Free a GPtrArray and its contents, by first calling free_func on
// each element iff free_func is not NULL, and then freeing the
// pointer array itself.
void
my_g_ptr_array_really_free (GPtrArray *array, FreeFunc free_func);

// Swap the byte order of a 32 bit value, hopefully converting from
// big endian to little endian or vice versa.  There is unfortunately
// some question whether or not this always works right for floating
// point values.
inline static void
swap_bytes_32 (gpointer in)
{
  // For efficiency only this assretion is commented out.
  // g_assert (sizeof (unsigned char) == 1);

  int tmp = ((unsigned char *) in)[0];
  ((unsigned char *) in)[0] = ((unsigned char *) in)[3];
  ((unsigned char *) in)[3] = tmp;
  tmp = ((unsigned char *) in)[1];
  ((unsigned char *) in)[1] = ((unsigned char *) in)[2];
  ((unsigned char *) in)[2] = tmp;
}

// Perform swap_bytes_32 on all count 32 bit values starting of buffer.
inline static void
swap_array_bytes_32 (gpointer buffer, size_t count)
{
  size_t ii;
  for ( ii = 0 ; ii < count ; ii++ ) {
    swap_bytes_32 (((guint32 *) buffer) + ii);
  }
}

// Sleep for time seconds.  This function ultimately calls nanosleep,
// which can get interrupted by a signal, in which case it returns the
// remaining sleep time.  If nanosleep is interrupted in this way,
// this routine returns the remaining time in gdouble form (otherwise
// it returns 0.0).
gdouble
my_sleep (gdouble time);

// Return a new string of the form "process_PID_thread_THREAD", where
// PID is the process ID of the calling process and THREAD is the the
// address of the current GThread.
GString *
pid_thread_string (void);

///////////////////////////////////////////////////////////////////////////////
//
// Simple Random Number Functions
//
// These depend on a call to srand being made somewhere if one doesn't
// want the same sequence every time.  They ultimately call rand_r, so
// are ultimately thread-safe, but not very random.
//
///////////////////////////////////////////////////////////////////////////////

// Return a random double from the range [0, 1].
gdouble
random_fraction (void);

// Return a random double from the range [0, max].
gdouble
my_random (gdouble max);

///////////////////////////////////////////////////////////////////////////////
//
// File and Directory Validation
//
// Functions to verify that a directory argument is valid.  In
// practice these function aren't really adequate, since the situation
// could change between the time when we check and the time the file
// is actually used.
//
///////////////////////////////////////////////////////////////////////////////

// Return TRUE iff path is a directory in which the calling process
// has read, write, and execute premissions, otherwise return FALSE
// and fill in *err with an appropriate message.
gboolean
my_is_writable_directory (const char *path, GError **err);

// Return TRUE iff path is a readable file, otherwise return FALSE and
// fill in *err with an appropriate message.
gboolean
my_is_readable_file (const char *path, GError **err);

///////////////////////////////////////////////////////////////////////////////
//
// Debugging
//
// Routines that try to help with debugging.
//
///////////////////////////////////////////////////////////////////////////////

// Print ": arg\n" (with printf()-style format interpretation) with a
// process/thread ID string prefixed (a trace message).
void
trmsg (const char *format, ...)
#ifdef __GNUC__
  __attribute__ ((format (printf, 1, 2)))
#endif 
; // <-- Semicolon for prototype.

// Dump GPtrArray of GString instances strings using g_print, one per
// line, with space_count spaces at the beginning of each line.
void
dump_array_of_strings (GPtrArray *strings, int space_count);

// Dump keys of GString keyed hash table table, one per line, with
// space_count spaces at the beginning of each line.
void
dump_keys_of_string_keyed_hash (GHashTable *table, int space_count);

// Dump GHashTable GString instance values using g_print, one per
// line, with space_count spaces at the beginning of each line.
void
dump_values_of_hash_of_strings (GHashTable *table, int space_count);

// Dump GHashTable instance keys and value arrays.  The keys must be
// GString instances, and the values must be GPtrArray instances of
// GString instances.  The output features space_count spaces of
// indentation at the start of each line, and internal_space_count
// additional spaces of indentation before the strings in the value
// arrays.
void
dump_gstring_keyed_hash_of_gptr_arrays_of_gstrings (GHashTable *table,
						    int space_count,
						    int internal_space_count);

// Sleep for a random amount of time from the interval [0, max_time).
// Useful for stressing multithreaded or multiprocess code.
void
random_delay (gdouble max_time);

///////////////////////////////////////////////////////////////////////////////

// Open file, treat it as a data_width wide block of rectangular data
// with elements of size element_size bytes each, and fetch a width by
// height region with upper left corner at element (start_x, start_y),
// returning it in new memory.  Close the file before returning
// (implicitly releasing any file locks the caller holds).
void *
my_read_data_rectangle (const char *file, size_t element_size,
			off64_t data_width, off64_t start_x, off64_t start_y,
			size_t width, size_t height);

#endif // UTILITIES_H
