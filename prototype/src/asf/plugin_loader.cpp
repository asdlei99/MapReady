/*
ASF Plugin Loader.  Loads asf::plugin objects 
from dynamically linked library files.

Orion Sky Lawlor, olawlor@acm.org, 2005/09/02.
*/
#include "asf/plugin_loader.h"
#include "osl/dll.h" /* Dynamically linked library load routines */
#include "osl/dir.h" /* Directory search routines */

ASF_COREDLL int asf::plugin_load_verbose=0;

/// Create a loader using plugins from the default search paths.
asf::plugin_loader::plugin_loader()
{
	if (getenv("ASF_LOAD_VERBOSE")) asf::plugin_load_verbose=1;
	const char *asf=getenv("ASF_LIBRARY_PATH");
	const char *home=getenv("HOME");
	if (asf) { /* Only load from the ASF_LIBRARY_PATH */
		const char *cpath=asf, *src="ASF_LIBARY_PATH";
		if (plugin_load_verbose) printf("Loading plugins from %s: '%s'\n",src,cpath);
		std::string path(cpath);
		std::string::size_type start=0;
		while (1) {
			std::string::size_type end=path.find(':',start);
			if (end==std::string::npos) end=path.size();
			dirs.push_back(path.substr(start,end-start));
			if (end==path.size()) break;
			start=end+1;
		}
	} 
	else 
	{ /* No specific directions given-- try the likely places */
		if (plugin_load_verbose) printf("Loading plugins from default places, since ASF_LIBRARY_PATH is not set\n");
		dirs.push_back(".");
		dirs.push_back("lib");
		dirs.push_back("../lib");
		dirs.push_back("../../lib");
#ifdef ASF_COREDLL_TOPDIR
		dirs.push_back(ASF_COREDLL_TOPDIR "/lib");
#endif
		dirs.push_back("asf_plugins/lib");
		if (home) {
			dirs.push_back(std::string(home)+"/asf_plugins/lib");
		}
	}
	if (plugin_load_verbose) {
		for (unsigned int i=0;i<dirs.size();i++)
			printf("    Plugin search path: '%s'\n",dirs[i].c_str());
	}
}

class plugin_load_directory_contents : public osl::directory_contents {
public:
	asf::plugin_loader &r;
	plugin_load_directory_contents(asf::plugin_loader &r_) :r(r_) {}
	
	void hit_file(const char *dirName,const char *fileName) {
		int nameLen=strlen(fileName);
		if (asf::plugin_load_verbose) {
			printf("\tFile '%s/%s'\n",dirName,fileName);
		}
		if (nameLen<4) return;
		if (0==strcmp(&fileName[nameLen-4],".dll")) { /* Looks like a dll-- load it! */
			std::string dirAndFile=dirName+std::string("/")+fileName;
			r.load_file(dirAndFile.c_str());
		}
	}
};

/// Load up all plugins found in the search path.
const asf::registry &asf::plugin_loader::load(void)
{
	plugin_load_directory_contents c(*this);
	for (int i=dirs.size()-1;i>=0;i--) { /* Loop over directories backwards, so last loaded is zero */
		c.list(dirs[i].c_str());
	}
	return global;
}

// FUNKY: I'm just going to use ".dll" everywhere, 
//   instead of the usual UNIX ".so" extension.
// #ifdef WIN32
# define LIBRARY_EXTENSION ".dll"
// #else /* UNIX? */
// # define LIBRARY_EXTENSION ".so"
// #endif

/// Load (or re-load) any plugins found with this library
///   base name anywhere in the search path.
const asf::registry *asf::plugin_loader::load_library(std::string library)
{
	for (unsigned int i=0;i<dirs.size();i++) {
		const asf::registry *r=load_file(dirs[i]+'/'+library+LIBRARY_EXTENSION);
		if (r) return r; /* Found it! */
		/* else keep looking */
	}
	return NULL; /* Not there */
}

/* A C main routine */
extern "C" {
typedef int (*c_main_fn)(void);
};

/// Load (or re-load) any plugins found in this library file
const asf::registry *asf::plugin_loader::load_file(std::string file)
{
	const char *status=NULL;
	int ret=0;
	std::string library;
	
	/* Open the DLL */
	osl_dll h=osl_dll_open(file.c_str());
	if (h==NULL) {status="dll open failed"; goto end;}
	
	{ /* Extract the library name */
		std::string::size_type lastSlash=file.rfind('/'); /* e.g., "asf_plugins/" */
		if (lastSlash==std::string::npos) lastSlash=file.rfind('\\'); /* Try windows backslash path */
		if (lastSlash==std::string::npos) lastSlash=0; else lastSlash++;
		
		std::string::size_type lastDot=file.find('.',lastSlash); /* e.g., ".dll", ".so" */
		if (lastDot==std::string::npos) lastDot=file.size();
		library=file.substr(lastSlash,lastDot-lastSlash);
		if (plugin_load_verbose) printf("\t\tLibrary '%s': file '%s'\n",library.c_str(),file.c_str());
	}
	
	/* Find the init function: first try "asf_plugin_init" */
	plugin_init_function_t fn;
	fn=(plugin_init_function_t)osl_dll_lookup(h,"asf_plugin_init");
	/* Next try "asf_plugin_init_<foo>", as generated by macro */
	if (fn==0) fn=(plugin_init_function_t)osl_dll_lookup(h,("asf_plugin_init_"+library).c_str());
	if (fn==0) { /* still no init routine-- try running its "main" routine (testing) */
		c_main_fn cmain=(c_main_fn)osl_dll_lookup(h,"main");
		if (cmain!=0) { /* has testing main routine-- run it! */
			printf("-------------------------------\n"
			"Executing test main routine for %s\n",file.c_str());
			cmain();
			status="testing main routine finished happily."; 
			goto end; 
		} else { /* no main routine--give up */
			status="does not contain asf_plugin_init (or main) routine"; 
			goto end; 
		}
	}
	else 
	{ /* Call the initialization function, to register all plugins and parameters */
		library_info *l=new library_info;
	
		ret=fn(&l->local);
		if (ret!=plugin_init_function_ok) {delete l; status="strange value returned from init routine"; goto end;}
		l->dll=h;
		lib[library]=l; /* file under library name */
		global.merge(l->local); /* Add this library to the global namespace */
		return &l->local;
	}
end: /* Error exit */
	if (plugin_load_verbose) {
		printf("\t\tLibrary '%s': %s\n",file.c_str(),status?status:"OK");
	}
	if (h) osl_dll_close(h); /* close library, to save memory */
	return NULL;
}


/** Build a new registry with all system and dynamically loaded plugins */
ASF_COREDLL void asf::dynamic_register(asf::registry &reg)
{
	asf::system_register(reg);
	asf::plugin_loader dlls; /* all dynamically loaded plugins */
	reg.merge(dlls.load());
}
